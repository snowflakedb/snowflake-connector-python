#!/bin/bash -e
#
# Initalize build
#
set -o pipefail

THIS_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
CONNECTOR_DIR="$( dirname "${THIS_DIR}")"
export PLATFORM=$(echo $(uname) | tr '[:upper:]' '[:lower:]')
export MACHINE=$(uname -m)
export CURRENT_USER=$(whoami)
export WORKSPACE=${WORKSPACE:-$HOME/sf/deployments/connectors}
mkdir -p $WORKSPACE || true
export PYTHON_ENV="35"
source "$THIS_DIR/py_exec.sh"

function is_host_port_used() {
    local host=$1
    local port=$2

    if [[ "$PLATFORM" == "darwin" ]]; then
        cat < /dev/null | nc -G 2 $host $port
    elif [[ "$PLATFORM" == "linux" ]]; then
        cat < /dev/null > /dev/tcp/$host/$port
    fi
}

function log() {
    local sev=$1
    local exp=$2

    color=7
    usev=$(echo $sev | tr '[:lower:]' '[:upper:]')
    case $usev in
        INFO) color=2 ;;
        ERROR) color=1 ;;
        WARNING|WARN) color=3 ;;
    esac
    tput setaf $color || true # ignore error
    echo "[$usev] $exp"
    tput sgr0 || true # ignore error
}

function help() {
    echo "$0 <options>"
    echo "--clean: clean artifacts"
    echo "--python-version: target Python version"
}

function run_filter() {
    #
    # Run Perl filter to update text
    #
    local dir=$1
    local pattern=$2
    cd "$dir"
    for f in $(find . -type f -exec grep -Iq . {} \; -and -print); do
        temp_file=$($MKTEMP)
        cat $f | perl -nle "$pattern" > $temp_file
        cp -f $temp_file $f || true
        rm -f $temp_file || true
    done
}

function is_up_to_date() {
    #
    # Is latest target?
    #
    local target_pkg=$1
    local target_dir=$2

    TARGET_PKG=$(ls $target_pkg 2>/dev/null | sort -r | head -n 1 || echo "")

    if [[ -n $TARGET_PKG ]]; then
        if [[ "$PLATFORM" == "darwin" ]]; then
            PKG_TS=$(stat -f "%m" $TARGET_PKG)
            LATEST_CHANGE_TS=$(find $target_dir -name "*" -exec stat -f "%m" {} \; | sort -nr | head -n 1)
        else
            PKG_TS=$(stat --format "%Y" $TARGET_PKG)
            LATEST_CHANGE_TS=$(find $target_dir -name "*" -exec stat --format "%Y" {} \; | sort -nr | head -n 1)
        fi
        PKG_TS=$(echo $PKG_TS)
        LATEST_CHANGE_TS=$(echo $LATEST_CHANGE_TS)
        if (( "$PKG_TS" >= "$LATEST_CHANGE_TS" )); then
            log INFO "$TARGET_PKG is the latest."
            return 0
        fi
    fi
    return 255
}

function run_cmd() {
    #
    # Run a command
    #
    local cmd=$1
    local log=$2
    local is_tee=$3

    log INFO "Running: $cmd, Log: $VIRTUAL_ENV_DIR/$log"
    echo "$cmd" >> $VIRTUAL_ENV_DIR/$log
    temp_file=$($MKTEMP)
    set +e
    if [[ -z "$is_tee" ]] ;then
        $cmd 2>&1 >> $temp_file
        ERRCODE=$?
        set -e
        if [[ "$ERRCODE" == "124" ]]; then
            log WARN "Timeout"
        elif [[ "$ERRCODE" != "0" ]]; then
            log ERROR "ERRCODE: $?"
            cat $temp_file
            log ERROR "$cmd"
            cat $temp_file >> $VIRTUAL_ENV_DIR/$log
            rm -f $temp_file
            exit 1
        fi
        cat $temp_file >> $VIRTUAL_ENV_DIR/$log
        rm -f $temp_file
    else
        $cmd 2>&1 | tee -a $VIRTUAL_ENV_DIR/$log
        ERRCODE=$?
        set -e
        if [[ "$ERRCODE" == "124" ]]; then
            log WARN "Timeout"
        elif [[ "$ERRCODE" != "0" ]]; then
            log ERROR "ERRCODE: $?"
            cat $VIRTUAL_ENV_DIR/$log
            log ERROR "$cmd"
            exit 1
        fi
    fi
}

function generate_version_file() {
    #
    # Generate a version file including SVN revision
    #
    local target="connector"
    local do_upload=$1

    log INFO "Generating generated_version.py: $target"
    if [[ -n "$do_upload" ]]; then
        log WARN "Deleting $CONNECTOR_DIR/generated_version.py"
        rm -f $CONNECTOR_DIR/generated_version.py* || true
    elif [[ -n "$python_svn_revision" ]]; then
        temp_file=$($MKTEMP)
        echo "# Generated by $0. Don't update" > \
            $CONNECTOR_DIR/generated_version.py || true
        cat $CONNECTOR_DIR/version.py | \
            sed "s#None#$python_svn_revision#" >> \
            $CONNECTOR_DIR/generated_version.py
    fi
}

function latest_wheel() {
    #
    # Get the latest wheel file for the given pattern
    #
    local pat=$1
    ls $pat 2>/dev/null | sort -r | head -n 1 || ""
}

function resetup_build_env() {
  resetup_env "$TOOLS_WORKSPACE"
}

function setup_build_env() {
  setup_env "$TOOLS_WORKSPACE"
}

function cleanup_workspace() {
    #
    # Clean up virtualenv workspace
    #
    local target="connector"

    if [[ -n "$CLEAN" || ! -e "$TOOLS_WORKSPACE" ]]; then
        log INFO "Preparing package virtualenv: $target"
        log WARN "Deleting artifacts for $target in $CONNECTOR_DIR/build, $CONNECTOR_DIR/dist, $TOOLS_WORKSPACE"
        rm -rf $CONNECTOR_DIR/build || true
        rm -rf $CONNECTOR_DIR/dist/snowflake{_,-}$target*.whl || true
        resetup_build_env
    else
        if [[ ! -d "$CONNECTOR_DIR/dist" ]]; then
          mkdir "$CONNECTOR_DIR/dist"
        fi
        cd $CONNECTOR_DIR/dist
        num_of_packages=$(ls snowflake_${target}*.whl 2>/dev/null | wc -l || true)
        if (( $num_of_packages > 1 )); then
            old_packages=$(ls snowflake_${target}*.whl 2>/dev/null | sort -r | tail -n $((num_of_packages-1)) || true)
            log WARN "Deleting old artifacts for $target: $old_packages"
            rm -f $old_packages
        else
            log INFO "No old package exists"
        fi
    fi
}

function create_wheel() {
    #
    # Create a wheel package
    #
    local target="connector"

    log INFO "Creating a wheel: snowflake_${target}"
    setup_build_env
    source $TOOLS_WORKSPACE/bin/activate
    cd $CONNECTOR_DIR
    which python
    python --version
    pip install wheel
    run_cmd "python setup.py bdist_wheel -d $CONNECTOR_DIR/dist" "build_tools.log"
    deactivate
}

function create_sdist() {
    #
    # Create a sdist package
    #
    local target="connector"

    log INFO "Creating a sdist: snowflake_${target}"
    setup_build_env
    source $TOOLS_WORKSPACE/bin/activate
    cd $CONNECTOR_DIR
    run_cmd "python setup.py sdist -d $CONNECTOR_DIR/dist" "build_tools.log"
    deactivate
}

function create_virtualenv() {
    local pv=$1
    local dir=$2
    local log=$3

    if [[ "${pv:0:1}" == "2" ]]; then
        run_cmd "virtualenv-$pv $dir" "$log"
    else
        run_cmd "python$pv -m venv $dir" "$log"
    fi
}

if [[ -z "$PIP_INDEX_URL" ]]; then
    unset PIP_FIND_LINKS
    unset PIP_NO_INDEX
    if [[ "$PLATFORM" == "darwin" ]]; then
        unset PIP_INDEX_URL
        log INFO "Using the public pypi"
    else
        true
#        export PIP_INDEX_URL="https://nexus.int.snowflakecomputing.com/repository/pypi/simple"
#        log INFO "Using the internal pypi: PIP_INDEX_URL=https://nexus.int.snowflakecomputing.com/repository/pypi/simple"
    fi
fi

function generate_reqs_file() {
  # Usage: generate_reqs_file "path_to_venv" "path_to_python executable" "/home/user/wheels/this.whl" "/virtualenvs/35"
    local venv=$1
    local python=$2
    local whl_tgt=$3
    local tmp_env=$4
    local reqs_file=$whl_tgt.reqs

    run_cmd "${venv} -p ${python} ${tmp_env}" "tmp_env.log"
    source $tmp_env/bin/activate
    run_cmd "pip install $whl_tgt" "connector_install.log"
    pip freeze | grep -v -e '^-f .*$' -e '^snowflake-connector-python==.*$' 1>$reqs_file 2>/dev/null
    log INFO "Requirements have been written to: $reqs_file"
    deactivate
    rm -rf $tmp_env
}

if [[ "$PLATFORM" == "darwin" ]]; then
    # short name parameter names only
    OPTS=$(getopt hcp "$*")
else
    # Local PyPI wheelhouse.
    # both short and long parameter names are supported
    OPTS=$(getopt -o ":hcp:" -l ":help,clean,python-version:" -- "$@")
fi
if [[ $? != 0 ]]; then
    help
    exit 2;
fi
eval set -- "$OPTS"
while true; do
    case "$1" in
        -c|--clean) export CLEAN=true; shift;;
        -p|--python-version) PYTHON_VERSION=$2; shift 2;;
        -h|--help) help; exit 0;;
        --) shift; break;;
    esac
done


export SF_REGRESS_LOGS=${SF_REGRESS_LOGS:-$WORKSPACE}

# Not sure where all we can find this, based on the different environments,
# but $THIS_DIR/.. is not always valid.
script_name="svnrevision.sh"
revision_script_base="GSCommon/src/main/scripts/${script_name}"
if [[ -e "$SF_PROJECT_ROOT/${revision_script_base}" ]]; then
    svn_revision_script="$SF_PROJECT_ROOT/${revision_script_base}"
elif [[ -e "$THIS_DIR/../../../../${revision_script_base}" ]]; then
    svn_revision_script="$THIS_DIR/../../../../${revision_script_base}"
else
    svn_revision_script="${THIS_DIR}/${script_name}"
fi

if [[ -z "$python_svn_revision" ]]; then
    if [[ -e "$svn_revision_script" ]]; then
        export python_svn_revision=$($svn_revision_script $THIS_DIR FORCE_INT)
        log INFO "python_svn_revision=$python_svn_revision"
    else
        log ERROR "Can't determine the svn revision, failing (not)"
        #exit 1
    fi
fi

export VIRTUAL_ENV_DIR=$WORKSPACE/virtualenv_dir
mkdir -p $VIRTUAL_ENV_DIR || true

if [[ "$PLATFORM" == "darwin" ]]; then
    export MKTEMP="mktemp -t snowflake"
    export ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future
else
    export MKTEMP=mktemp
fi
export SNOWSQL_KEYS_WORKSPACE=$VIRTUAL_ENV_DIR/snowsql_keys
export TOOLS_WORKSPACE=$VIRTUAL_ENV_DIR/package_workspace
